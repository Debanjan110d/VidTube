1. npm init --y // -y means yes to all questions(Do not forget to change the type form "common" to "module" in the package.json file)
2. npm i -d // Means download dependencies
3. npm i -D // Means download dev dependencies 
 in this you should install nodemon and prettier //the command will look like this :
       npm i -D nodemon prettier
    nodemon: for live server and continously refresh it automatically
    prettier: for code formatting (create a " .prettierrc " file in the root directory  ; its a rc file)
            in this file you can write your code formatting preferences like 
            {
                "singleQuote": false,
                "bracketSpacing": true,
                "tabWidth": 2,
                "trailingComma": "es5",
                "semi": true
            }
        then create prettierignore file in the root directory(this file is used to ignore files that are not to be formatted)
            in this file you can write the name of the files that are not to be formatted like:
                /.vscode
                /node_modules
                ./distribution


                *.env
                .env
                .env.*
                notes.txt
4.create src folder in the root directory
5. Then run this command(Try to use bash terminal) to create all the folders in src:
    cd src
    mkdir controllers db middlewares models routes utils
6.Then create some files in src :(using touch command):
     touch app.js index.js constants.js .env .env.sample
7.Create a index.js file in db folder:
    touch index.js(purpose is to have a database connection)
8.Create some files in models folder:
     touch comment.models.js like.models.js playlist.models.js subscriptions.models.js tweet.models.js videos.models.js
9.Installing Express:
    npm i express
10.Installing Mongoose:
    npm i mongoose
11.Test the code is woriking or not by addin g a simple console.log("Hello World") in the index.js file 
12. Now to run the index.js file We need to setup a few things in the package.json file:
    "scripts": {
        start: "node src/index.js",
    } 
13.Now we will create the main cocmmand to run the index.js file:
    "scripts": {
        "dev": "nodemon src/index.js"
    }
14.To run these use the follwing command wichever you like :
    npm run dev

    |or|

    npm dev

15. **IMPORTANT CHANGE**: .env file location changed to src folder (not main folder)
    The .env file should be in src/ folder: src/.env
    Reason: Better organization and security practices

16.NOw install dotenv:(To tell express to use the .env file)
    npm i dotenv
       then add this in the index.js (NOT app.js):
       import dotenv from 'dotenv'
       dotenv.config({
           path:"./src/.env"  // UPDATED PATH - runs from project root
       })
        therefore change the port variable to process.env.PORT:
            const PORT =  process.env.PORT || 5000

17. Install cors package:(to allow cross origin resource sharing andmentioning the people who cna share the data with us)
    npm i cors
*From here on the code will be in there files 

1.Go to app.js adn write some code 

2.In .env file write the port number and these:
    PORT=8000  // NO SPACES around = sign (standard practice)
    # CORS_ORIGIN =* This * means allowing everything thats noot a good Idea 
    # CORS_ORIGIN =http://localhost:8000 To make it more secure in the development seceniro (Totallyt depends on your needs)
    #Also add the frontend url here, to make it more secure in the future
    CORS_ORIGIN=http://localhost:3000  // ACTIVE setting for frontend connection
    
    MONGO_URI=mongodb+srv://username:password@cluster.mongodb.net  
    // CRITICAL: NO angle brackets < > around username/password - use actual values!
    #Never Keep any slash at the end the of every environment variables , its will save you from a lot of troubles

3.add a public folder in the root directry to add the static files like images and videos:
    mkdir public
    also do not forget to give them permisssion them thorugh the app.js :
    app.use(express.static("public"))

===================== RECENT UPDATES & FIXES =====================

18. **CRITICAL FIXES APPLIED**:
    
    A) MongoDB Connection Issues Fixed:
       - Problem: URI had angle brackets mongodb+srv://<username>:<password>@...
       - Fix: Remove brackets, use actual credentials: mongodb+srv://username:password@...
       - Cause: Angle brackets are documentation placeholders, not actual syntax
    
    B) Environment File Path Fixed:
       - Problem: dotenv.config({ path: '../.env' }) looked in wrong directory
       - Fix: Changed to { path: './src/.env' } - correct path from project root
       - Cause: Script runs from project root, not src folder
    
    C) Missing CORS Configuration:
       - Problem: CORS_ORIGIN was commented out, causing undefined variable
       - Fix: Added active CORS_ORIGIN=http://localhost:3000
       - Cause: Frontend needs explicit CORS permission
    
    D) Environment Variable Formatting:
       - Problem: Extra spaces around = sign (PORT = 8000)
       - Fix: Removed spaces (PORT=8000)
       - Cause: Some parsers are sensitive to whitespace

19. **NEW FILES CREATED**:
    - TROUBLESHOOTING.md - Comprehensive problem-solving guide
    - Updated README.md with quick start guide and troubleshooting link
    - asyncHandler.js in utils/ folder (for error handling)

20. **STANDARD PRACTICES IMPLEMENTED**:
    
    A) Environment Variables:
       - No spaces around = sign
       - No trailing slashes
       - Use descriptive comments
       - Validate required variables exist
    
    B) Project Structure:
       - .env files in src/ for better organization
       - Proper relative paths from execution directory
       - Clear separation of concerns
    
    C) Error Handling:
       - MongoDB connection error logging
       - Environment validation
       - Graceful server startup/shutdown
    
    D) Security:
       - Specific CORS origins (not wildcard *)
       - Environment files in .gitignore
       - No sensitive data in version control

21. **TROUBLESHOOTING CHECKLIST**:
    - ✅ MongoDB URI format (no angle brackets)
    - ✅ Environment file path (./src/.env from project root)
    - ✅ Required env vars set (PORT, CORS_ORIGIN, MONGO_URI)
    - ✅ No extra spaces in .env file
    - ✅ MongoDB Atlas credentials correct
    - ✅ Network connectivity to MongoDB cluster

22. **COMMANDS TO VERIFY SETUP**:
    - npm run dev (should connect to MongoDB and start server)
    - Check console for "MongoDB connected" and "Server running on port X"
    - Visit http://localhost:8000 to test server
    - Check TROUBLESHOOTING.md if issues persist

23. **ASYNCHANDLER UTILITY CREATED** (Higher-Order Function for Error Handling):
    
    A) **File Created**: src/utils/asyncHandler.js
       Purpose: Eliminates try-catch blocks in every async route handler
    
    B) **What is a Higher-Order Function?**:
       - A function that takes another function as argument OR returns a function
       - asyncHandler does BOTH: takes requestHandler function, returns enhanced function
       - Enables function composition and code reuse
    
    C) **How asyncHandler Works**:
       ```javascript
       const asyncHandler = (requestHandler) => {
           return (req, res, next) => {
               Promise.resolve(requestHandler(req, res, next)).catch((err) => next(err));
           };
       }
       ```
    
    D) **Step-by-Step Execution**:
       1. Takes requestHandler function as parameter (HOF concept - function as argument)
       2. Returns new function with (req, res, next) signature (HOF concept - function as return)
       3. Wraps requestHandler in Promise.resolve() for consistent error handling
       4. .catch() automatically passes any errors to Express error middleware
       5. Uses closure to remember the original requestHandler function
    
    E) **Without asyncHandler (Traditional - Repetitive)**:
       ```javascript
       const getUser = async (req, res, next) => {
           try {
               const user = await User.findById(req.params.id);
               res.json(user);
           } catch (error) {
               next(error); // Manual error handling in EVERY function
           }
       };
       ```
    
    F) **With asyncHandler (Clean - No Repetition)**:
       ```javascript
       const getUser = asyncHandler(async (req, res) => {
           const user = await User.findById(req.params.id);
           res.json(user);
           // No try-catch needed! asyncHandler handles errors automatically
       });
       ```
    
    G) **Higher-Order Function Concepts Demonstrated**:
       - Function Composition: Combining error handling with business logic
       - Abstraction: Hiding complex error handling behind simple interface
       - Decorator Pattern: Adding functionality to existing functions
       - Closure: Returned function remembers requestHandler parameter
       - Code Reusability: Write error handling once, use everywhere
    
    H) **How to Use in Controllers**:
       1. Import: import { asyncHandler } from '../utils/asyncHandler.js';
       2. Wrap controllers: const myController = asyncHandler(async (req, res) => { ... });
       3. Use in routes: router.get('/path', myController);
       4. All errors automatically handled!
    
    I) **Why Promise.resolve() is Used**:
       - Wraps both async and sync functions in Promise for consistent handling
       - Catches thrown errors and rejected Promises uniformly
       - Ensures .catch() always intercepts errors
       - Passes errors to Express error middleware via next(err)

24. **APIERROR UTILITY CREATED** (Custom Error Class for Standardized Error Handling):
    
    A) **File Created**: src/utils/apiError.js
       Purpose: Create consistent, structured error objects across the application
    
    B) **Key Learning - JavaScript's Built-in Error Class**:
       QUESTION: "Does Error class already exist as a child class?"
       ANSWER: No! Error is JavaScript's BUILT-IN class, not something we created
       
       - Error is a native JavaScript constructor function/class
       - Available globally in all JavaScript environments (browser, Node.js)
       - Provides standard error properties: message, name, stack
       - Other built-in error types: TypeError, ReferenceError, SyntaxError, etc.
    
    C) **Class Inheritance Concept**:
       ```javascript
       class ApiError extends Error {  // Extending JavaScript's built-in Error class
           constructor(statusCode, message = "Something went wrong", errors = [], stack = "") {
               super();  // MUST call super() when extending a class
               // Custom properties added to built-in Error functionality
           }
       }
       ```
    
    D) **Why super() is Required**:
       - When extending any class (especially built-in classes), must call super()
       - super() calls the parent class constructor (Error constructor)
       - Initializes inherited properties and methods from Error class
       - Without super(), you get an error: "Must call super constructor"
    
    E) **What is Stack Trace?**:
       QUESTION: "What is this stack?"
       ANSWER: Stack trace is a debugging tool showing the call chain that led to an error
       
       Components of Stack Trace:
       - Function names that were called
       - File names where functions are located  
       - Line numbers where each function was called
       - Call order (most recent call at the top)
       
       Example Stack Trace:
       ```
       Error: User not found
           at getUserById (/project/controllers/user.js:25:15)    ← Error occurred here
           at /project/routes/user.js:12:8                       ← Called from here
           at Layer.handle (/node_modules/express/lib/router/layer.js:95:5)
       ```
    
    F) **Error.captureStackTrace() Explanation**:
       ```javascript
       if (stack) {
           this.stack = stack;  // Use provided stack trace
       } else {
           Error.captureStackTrace(this, this.constructor);  // Generate new stack trace
       }
       ```
       
       - Built-in Node.js method for generating stack traces
       - First parameter (this): The error object to attach stack to
       - Second parameter (this.constructor): Excludes constructor from trace (cleaner output)
       - Creates breadcrumb trail showing exactly where error originated
    
    G) **Custom Properties Added to Built-in Error**:
       - statusCode: HTTP status code (404, 500, etc.)
       - message: Error description (inherited from Error class)
       - data: null (placeholder for additional data)
       - success: false (indicates API failure)
       - errors: Array of validation errors or multiple error messages
       - stack: Stack trace for debugging (inherited and customizable)
    
    H) **Real-World Usage Examples**:
       ```javascript
       // Import the custom error class
       import { ApiError } from '../utils/apiError.js';
       
       // Throw custom errors in controllers
       throw new ApiError(404, "User not found");
       throw new ApiError(400, "Invalid email format", ["Email is required"]);
       throw new ApiError(500, "Database connection failed");
       ```
    
    I) **Benefits of Custom Error Class**:
       - Consistent error structure across entire application
       - Automatic HTTP status codes for API responses
       - Built-in success/failure indicators
       - Support for multiple error messages
       - Enhanced debugging with stack traces
       - Standardized error handling in middleware

25. **LEARNING SUMMARY - Object-Oriented Programming Concepts**:
    
    A) **Class Inheritance**: 
       - Extending built-in JavaScript classes (Error)
       - Using super() to call parent constructor
       - Adding custom properties to inherited functionality
    
    B) **Error Handling Architecture**:
       - asyncHandler: Wrapper for automatic error catching
       - ApiError: Standardized error object creation
       - Both work together for comprehensive error management
    
    C) **JavaScript Built-in Classes Understanding**:
       - Error, TypeError, ReferenceError are native to JavaScript
       - Not custom classes - they exist in the language itself
       - Can be extended to create custom error types
    
    D) **Debugging Tools**:
       - Stack traces for tracking error origins
       - Error.captureStackTrace() for custom stack generation
       - Understanding call chains and execution flow

26. **NEXT STEPS**:
    - Create ApiResponse utility class for success responses
    - Implement user authentication models
    - Set up API routes in routes/ folder
    - Create controller functions using asyncHandler and ApiError
    - Add middleware for authentication/validation
    - Implement file upload for videos/images
    - Create Express error middleware to handle ApiError objects
